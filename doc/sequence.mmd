sequenceDiagram
    autonumber

    actor Client as "Client (Web/3D)"

box Aqua "Processus Principal (FastAPI / Asyncio)"
participant API as "API Routes<br/>(main.py)"
participant Session as "SessionManager<br/>(AnimationSession)"
participant Broadcast as "Broadcaster Task<br/>(Asyncio Loop)"
end

box "Communication Inter-Processus (IPC)" #F0F0F0
participant Pipe as "Command Pipe<br/>(Duplex Connection)"
participant Queue as "Frame Queue<br/>(mp.Queue)"
participant SHM as "Shared Memory<br/>(RAM /dev/shm)"
end

box "Processus Enfant (Engine & Animator)" #FFE6E6
participant Engine as "AnimationEngine<br/>(Process)"
participant Animator as "Animator<br/>(FK Logic)"
end

%% == Phase 1 : Initialisation & Handshake ==
note over API, Engine: Phase 1 : Initialisation & Handshake (Poignée de main)<br/>L'objectif est de démarrer le moteur lourd sans bloquer le serveur Web.

Client->>API: POST /sessions {id, file.fbx}
activate API

API->>Session: create_session()
activate Session

Session->>Engine: start() (Spawn Process)
activate Engine

note right of Engine: **Démarrage Processus**<br/>Le moteur démarre mais ne connaît pas<br/>encore la mémoire partagée.<br/>Il charge le fichier d'animation en attendant.

Engine->>Animator: initialize("file.fbx")
activate Animator
Animator-->>Engine: return {skeleton_struct, frame_size_bytes}
deactivate Animator

Engine->>Pipe: send(("init_success", {skeleton, frame_size}, None))
note right of Pipe: Le moteur envoie les métadonnées réelles<br/>et attend la configuration SHM

Session->>Pipe: poll(timeout=10) -> True
Session->>Pipe: recv() -> ("init_success", {skeleton, frame_size})
note left of Session: **Attente Active (Thread Executor)**<br/>1. **poll(timeout)** : Vérifie si des données arrivent (attend max 10s).<br/>2. **recv()** : Lit le message "init_success".<br/>Ceci est exécuté dans un thread à part pour ne pas figer l'API.

Session->>SHM: SharedMemory(create=True, size=frame_size * 3)
activate SHM
note right of Session: Allocation RAM (Triple Buffer)

Session->>Pipe: send(("set_shm", shm_name, False))
Session->>Broadcast: create_task(broadcast_loop)
activate Broadcast

API-->>Client: 200 OK (Session Created)
deactivate API

Engine->>Pipe: recv() -> ("set_shm", name, _)
Engine->>SHM: SharedMemory(name=name)
note right of Engine: Le moteur s'attache à la RAM existante

%% == Phase 2 : Boucle de Streaming ==
note over API, Engine: Phase 2 : Boucle de Streaming (Zero-Copy Pattern)

par Exécution Parallèle (Multiprocessing)

loop Boucle Moteur (ex: 60Hz)
opt 1. Traitement Commandes
Engine->>Pipe: poll()
note right of Engine: **Check Non-Bloquant**<br/>poll() retourne instantanément True/False.<br/>Si False (pas de message), on continue le calcul<br/>sans perdre de temps.
alt Si poll() est True
Engine->>Pipe: recv() (Lecture bloquante mais sûre car poll=True)
Engine->>Engine: Mise à jour état interne<br/>(vitesse, pause, seek...)
end
end

opt 2. Calcul & Écriture RAM
Engine->>Animator: write_frame(shm_buffer, offset, dt)
activate Animator
Animator->>SHM: Écriture directe (numpy buffer protocol)
note right of Animator: **ZERO-COPY**<br/>Les matrices 4x4 sont écrites directement<br/>dans la mémoire partagée.<br/>Pas de sérialisation JSON.
deactivate Animator
end

opt 3. Synchronisation
Engine->>Queue: put(slot_index)
note right of Queue: On envoie seulement un entier (ex: 0, 1 ou 2) pour le slot_index.
end
end

and Boucle Broadcast (Asyncio)

loop Broadcast Loop
Broadcast->>Queue: await loop.run_in_executor(get)
note left of Queue: Attend qu'une frame soit prête.<br/>Si il reçoit un slot_index -> une frame est disponible

Broadcast->>SHM: memoryview(buf)[offset:end]
note left of Broadcast: **Lecture Zero-Copy**<br/>Crée une vue sur la RAM<br/>sans copier les données.<br/>Où offset = slot_index * frame_size

Broadcast->>Client: websocket.send_bytes(view)
note left of Client: Le client reçoit un ArrayBuffer binaire
end

end

%% == Phase 3 : Commande de Contrôle ==
note over API, Engine: Phase 3 : Commande de Contrôle (Ex: Changement Vitesse)

Client->>API: POST /sessions/{id}/speed {speed: 2.0}
activate API

API->>Session: await set_speed(2.0)

note right of Session: **Protection AsyncLock**<br/>Empêche deux requêtes simultanées<br/>d'écrire dans le Pipe en même temps.

Session->>Pipe: send(("set_speed", 2.0, False))
note right of Pipe: False = "Ne pas attendre de réponse" (Fire & Forget)

API-->>Client: 200 OK
deactivate API

note over Engine: Au tour de boucle suivant...
Engine->>Pipe: poll() -> True
Engine->>Pipe: recv() -> ("set_speed", 2.0, False)
Engine->>Engine: current_speed = 2.0

note right of Engine: **Application**<br/>Le prochain calcul utilisera :<br/>dt = target_dt * 2.0
